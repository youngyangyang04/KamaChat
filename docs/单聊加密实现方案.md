# 单聊端到端加密实现方案

## 1. 系统目标

### 核心需求
- ✅ **端到端加密**：服务器无法解密单聊消息内容
- ✅ **前向安全**：密钥泄露不影响历史消息安全
- ✅ **身份验证**：确保消息来自真实发送者
- ✅ **兼容现有系统**：最小化对现有代码的改动

### 非目标（本阶段不实现）
- ❌ 群组消息加密
- ❌ 跨设备消息同步
- ❌ 历史消息云端备份

### 安全原则
- 服务器只存储加密后的消息内容
- 密钥仅在客户端生成、存储和使用
- 每条消息使用不同的加密密钥（通过密钥链派生）
- 明文消息和密钥永不触碰服务器

---

## 2. 密钥体系架构

### 2.1 用户密钥对

每个用户注册时需要生成以下密钥对：

#### a) 身份密钥对 (Identity Key Pair)
- **用途**：长期身份标识，用于签名其他密钥
- **算法**：Ed25519（签名算法）
- **生命周期**：账号创建时生成，除非账号迁移否则不更换
- **存储**：
  - 私钥：客户端本地加密存储（IndexedDB/LocalStorage 加密）
  - 公钥：上传到服务器，供其他用户获取

#### b) 签名预密钥对 (Signed Pre Key)
- **用途**：用于建立会话的中期密钥
- **算法**：Curve25519（ECDH 密钥交换）
- **生命周期**：定期轮换（建议每 30 天）
- **签名**：使用身份私钥签名，证明密钥真实性
- **存储**：
  - 私钥：客户端本地加密存储
  - 公钥 + 签名：上传到服务器

#### c) 一次性预密钥 (One-Time Pre Keys)
- **用途**：提供前向安全性，每次会话消耗一个
- **算法**：Curve25519
- **数量**：预生成 100 个，用完后补充
- **使用策略**：先到先得，用一次删除一次
- **存储**：
  - 私钥：客户端本地加密存储
  - 公钥：批量上传到服务器

### 2.2 会话密钥（动态生成）

#### a) Root Key（根密钥）
- **用途**：派生新的链密钥
- **生命周期**：每次 DH 棘轮更新时更新

#### b) Chain Key（链密钥）
- **用途**：派生消息密钥
- **分类**：
  - 发送链密钥（Sending Chain Key）
  - 接收链密钥（Receiving Chain Key）
- **更新**：每次发送/接收消息后更新

#### c) Message Key（消息密钥）
- **用途**：加密单条消息
- **派生**：从链密钥派生
- **使用**：一次性使用，用完即删除

### 2.3 密钥保护

所有客户端存储的私钥需要用主密钥加密：

```
用户密码 (Password)
    ↓
PBKDF2 (100,000 迭代 + Salt)
    ↓
主密钥 (Master Key, 256 bit)
    ↓
AES-256-GCM 加密
    ↓
加密存储的私钥
```

**主密钥不存储在任何地方**，每次用户登录时从密码重新派生。

---

## 3. Signal Protocol 实现细节

### 3.1 X3DH 协议（会话建立）

当 Alice 首次给 Bob 发消息时，执行 X3DH 密钥协商：

#### 步骤 1：Alice 获取 Bob 的公钥束

Alice 向服务器请求 Bob 的公钥束，包含：
- `IK_B`：Bob 的身份公钥
- `SPK_B`：Bob 的签名预公钥
- `SPK_B_Signature`：对 SPK_B 的签名
- `OPK_B`（可选）：Bob 的一次性预公钥

服务器响应数据结构：
```json
{
  "user_id": "bob_uuid",
  "identity_key": "Base64(IK_B)",
  "signed_pre_key": {
    "key_id": 1,
    "public_key": "Base64(SPK_B)",
    "signature": "Base64(SPK_B_Signature)"
  },
  "one_time_pre_key": {
    "key_id": 42,
    "public_key": "Base64(OPK_B)"
  }
}
```

#### 步骤 2：Alice 验证签名

Alice 使用 Bob 的身份公钥 `IK_B` 验证 `SPK_B_Signature`，确保 `SPK_B` 确实由 Bob 生成。

#### 步骤 3：Alice 生成临时密钥对

Alice 生成临时密钥对 `(EK_A_private, EK_A_public)`。

#### 步骤 4：执行 4 次 ECDH 密钥交换

```
DH1 = ECDH(IK_A_private, SPK_B_public)
DH2 = ECDH(EK_A_private, IK_B_public)
DH3 = ECDH(EK_A_private, SPK_B_public)
DH4 = ECDH(EK_A_private, OPK_B_public)  [如果有 OPK]
```

#### 步骤 5：派生初始密钥

```
SK = KDF(DH1 || DH2 || DH3 || DH4)
Root_Key = KDF(SK, "RootKey")
Chain_Key_Send = KDF(SK, "ChainKeySend")
Chain_Key_Receive = KDF(SK, "ChainKeyReceive")
```

#### 步骤 6：Alice 发送初始消息

Alice 构造初始消息包：
```json
{
  "type": "PreKeyMessage",
  "sender_id": "alice_uuid",
  "receiver_id": "bob_uuid",
  "identity_key": "Base64(IK_A)",
  "ephemeral_key": "Base64(EK_A)",
  "used_one_time_pre_key_id": 42,
  "encrypted_message": {
    "ciphertext": "Base64(加密消息)",
    "iv": "Base64(初始化向量)",
    "auth_tag": "Base64(认证标签)"
  }
}
```

#### 步骤 7：Bob 接收并响应

Bob 收到消息后：
1. 提取 Alice 的身份公钥 `IK_A` 和临时公钥 `EK_A`
2. 查找对应的私钥（`IK_B_private`, `SPK_B_private`, `OPK_B_private`）
3. 执行相同的 4 次 ECDH 和密钥派生
4. 得到相同的会话密钥
5. 解密消息
6. 删除已使用的一次性预公钥 `OPK_B`

### 3.2 双棘轮算法（后续消息）

会话建立后，后续消息使用双棘轮算法加密。

#### 对称密钥棘轮（KDF Chain）

每次发送/接收消息时，更新链密钥：

**发送消息**：
```
Message_Key = KDF(Chain_Key_Send, "MessageKey")
New_Chain_Key_Send = KDF(Chain_Key_Send, "ChainKey")

# 使用 Message_Key 加密消息
Ciphertext = AES-256-GCM(Message_Key, Plaintext)

# 更新链密钥
Chain_Key_Send = New_Chain_Key_Send

# 删除 Message_Key（前向安全）
```

**接收消息**：
```
Message_Key = KDF(Chain_Key_Receive, "MessageKey")
New_Chain_Key_Receive = KDF(Chain_Key_Receive, "ChainKey")

# 使用 Message_Key 解密消息
Plaintext = AES-GCM-Decrypt(Message_Key, Ciphertext)

# 更新链密钥
Chain_Key_Receive = New_Chain_Key_Receive

# 删除 Message_Key
```

#### DH 棘轮（定期更新）

每隔一定数量的消息（如 100 条），或一定时间（如 24 小时），执行 DH 棘轮更新：

1. **发送方**生成新的 DH 密钥对 `(Ratchet_Private, Ratchet_Public)`
2. 使用对方的上一个 DH 公钥进行 ECDH
3. 更新 Root Key 和 Chain Keys
4. 在消息中附带新的 `Ratchet_Public`

**更新流程**：
```
DH_Output = ECDH(Ratchet_Private_New, Ratchet_Public_Remote)
New_Root_Key = KDF(Root_Key_Old, DH_Output, "RootKey")
New_Chain_Key_Send = KDF(Root_Key_Old, DH_Output, "ChainKeySend")

Root_Key = New_Root_Key
Chain_Key_Send = New_Chain_Key_Send
```

### 3.3 消息格式

#### 初始消息（PreKeyMessage）
```json
{
  "version": 1,
  "type": "PreKeyMessage",
  "sender_id": "alice_uuid",
  "receiver_id": "bob_uuid",
  "timestamp": 1700000000000,
  "identity_key": "Base64(IK_A)",
  "ephemeral_key": "Base64(EK_A)",
  "used_one_time_pre_key_id": 42,
  "base_key": "Base64(初始 DH 公钥)",
  "encrypted_message": {
    "ciphertext": "Base64(...)",
    "iv": "Base64(...)",
    "auth_tag": "Base64(...)"
  }
}
```

#### 后续消息（SignalMessage）
```json
{
  "version": 1,
  "type": "SignalMessage",
  "sender_id": "alice_uuid",
  "receiver_id": "bob_uuid",
  "timestamp": 1700000100000,
  "ratchet_key": "Base64(当前 DH 公钥)",
  "counter": 15,
  "prev_counter": 12,
  "ciphertext": "Base64(...)",
  "iv": "Base64(...)",
  "auth_tag": "Base64(...)"
}
```

**字段说明**：
- `ratchet_key`：当前发送方的 DH 公钥，用于接收方更新会话
- `counter`：当前链的消息计数器
- `prev_counter`：上一个接收链的最后计数器（用于确认）
- `ciphertext`：AES-256-GCM 加密的消息内容
- `iv`：AES-GCM 初始化向量（12 字节）
- `auth_tag`：AES-GCM 认证标签（16 字节）

---

## 4. 数据库设计

### 4.1 服务器数据库修改

#### 4.1.1 用户表 (user_info) 增加字段

```sql
-- 身份公钥
ALTER TABLE user_info ADD COLUMN identity_key_public TEXT;

-- 签名预公钥
ALTER TABLE user_info ADD COLUMN signed_pre_key_id INT DEFAULT 1;
ALTER TABLE user_info ADD COLUMN signed_pre_key_public TEXT;
ALTER TABLE user_info ADD COLUMN signed_pre_key_signature TEXT;
ALTER TABLE user_info ADD COLUMN signed_pre_key_timestamp TIMESTAMP;

-- 密钥代数（用于密钥轮换）
ALTER TABLE user_info ADD COLUMN key_generation INT DEFAULT 1;
```

#### 4.1.2 一次性预密钥表 (one_time_pre_keys)

```sql
CREATE TABLE one_time_pre_keys (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(20) NOT NULL REFERENCES user_info(uuid) ON DELETE CASCADE,
    key_id INT NOT NULL,
    public_key TEXT NOT NULL,
    uploaded_at TIMESTAMP NOT NULL DEFAULT NOW(),
    used BOOLEAN DEFAULT FALSE,
    used_at TIMESTAMP,
    used_by_user_id VARCHAR(20),  -- 记录被谁使用
    UNIQUE(user_id, key_id),
    INDEX idx_user_unused (user_id, used) WHERE used = FALSE
);

COMMENT ON TABLE one_time_pre_keys IS '一次性预密钥，用于 X3DH 协商';
COMMENT ON COLUMN one_time_pre_keys.key_id IS '密钥 ID，由客户端生成';
COMMENT ON COLUMN one_time_pre_keys.used IS '是否已被使用';
```

#### 4.1.3 消息表 (message) 增加加密字段

```sql
-- 加密相关字段
ALTER TABLE message ADD COLUMN is_encrypted BOOLEAN DEFAULT FALSE;
ALTER TABLE message ADD COLUMN encryption_version INT DEFAULT 1;
ALTER TABLE message ADD COLUMN message_type VARCHAR(20) DEFAULT 'SignalMessage';  -- 'PreKeyMessage' 或 'SignalMessage'

-- Signal Protocol 相关
ALTER TABLE message ADD COLUMN sender_identity_key TEXT;  -- 初始消息需要
ALTER TABLE message ADD COLUMN sender_ephemeral_key TEXT;  -- 初始消息需要
ALTER TABLE message ADD COLUMN used_one_time_pre_key_id INT;  -- 初始消息需要
ALTER TABLE message ADD COLUMN ratchet_key TEXT;  -- 当前 DH 公钥
ALTER TABLE message ADD COLUMN counter INT;  -- 消息计数器
ALTER TABLE message ADD COLUMN prev_counter INT;  -- 前一个链的计数

-- 加密数据
ALTER TABLE message ADD COLUMN iv TEXT;  -- 初始化向量 (Base64)
ALTER TABLE message ADD COLUMN auth_tag TEXT;  -- 认证标签 (Base64)

-- content 和 url 字段现在存储加密后的 Base64 数据
COMMENT ON COLUMN message.content IS '加密后的消息内容 (Base64)，服务器无法解密';
COMMENT ON COLUMN message.is_encrypted IS '是否为加密消息';
```

**向后兼容性**：
- 现有未加密消息：`is_encrypted = FALSE`
- 新的加密消息：`is_encrypted = TRUE`
- 客户端根据 `is_encrypted` 字段决定是否解密

#### 4.1.4 密钥补充记录表 (key_replenishment_log)

```sql
CREATE TABLE key_replenishment_log (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(20) NOT NULL REFERENCES user_info(uuid) ON DELETE CASCADE,
    replenished_at TIMESTAMP NOT NULL DEFAULT NOW(),
    keys_added INT NOT NULL,
    remaining_keys INT NOT NULL,
    INDEX idx_user_time (user_id, replenished_at)
);

COMMENT ON TABLE key_replenishment_log IS '一次性预密钥补充记录';
```

### 4.2 客户端本地数据库

客户端使用 IndexedDB（浏览器）存储加密相关数据。

#### 4.2.1 数据库结构

**数据库名称**：`wework_crypto`
**版本**：1

#### 4.2.2 Object Stores

##### a) user_keys（用户密钥）

```javascript
{
  storeName: 'user_keys',
  keyPath: 'key_type',
  indexes: [
    { name: 'created_at', keyPath: 'created_at' }
  ]
}
```

数据结构：
```javascript
{
  key_type: 'identity' | 'signed_pre_key' | 'one_time_pre_1',
  private_key: Uint8Array,  // 加密后的私钥
  public_key: Uint8Array,
  key_id: number,           // 对于预密钥
  signature: Uint8Array,    // 对于签名预密钥
  created_at: timestamp,
  expires_at: timestamp     // 对于签名预密钥
}
```

##### b) sessions（会话状态）

```javascript
{
  storeName: 'sessions',
  keyPath: 'contact_id',
  indexes: [
    { name: 'updated_at', keyPath: 'updated_at' }
  ]
}
```

数据结构：
```javascript
{
  contact_id: 'bob_uuid',
  
  // Root Key
  root_key: Uint8Array,
  
  // 发送链
  sending_chain_key: Uint8Array,
  sending_ratchet_key_private: Uint8Array,
  sending_ratchet_key_public: Uint8Array,
  
  // 接收链
  receiving_chain_key: Uint8Array,
  receiving_ratchet_key_public: Uint8Array,
  
  // 计数器
  send_counter: number,
  receive_counter: number,
  prev_counter: number,
  
  // 对方身份
  remote_identity_key: Uint8Array,
  
  // 元数据
  created_at: timestamp,
  updated_at: timestamp,
  last_message_at: timestamp
}
```

##### c) message_keys_cache（消息密钥缓存）

用于处理乱序到达的消息。

```javascript
{
  storeName: 'message_keys_cache',
  keyPath: 'id',
  autoIncrement: true,
  indexes: [
    { name: 'contact_ratchet_counter', keyPath: ['contact_id', 'ratchet_key', 'counter'], unique: true },
    { name: 'created_at', keyPath: 'created_at' }
  ]
}
```

数据结构：
```javascript
{
  id: auto_increment,
  contact_id: 'bob_uuid',
  ratchet_key: Uint8Array,  // 对应的 DH 公钥
  counter: number,
  message_key: Uint8Array,
  created_at: timestamp,
  expires_at: timestamp     // 7 天后过期
}
```

##### d) encrypted_messages（本地加密消息缓存）

可选，用于提升性能。

```javascript
{
  storeName: 'encrypted_messages',
  keyPath: 'message_id',
  indexes: [
    { name: 'contact_id', keyPath: 'contact_id' },
    { name: 'created_at', keyPath: 'created_at' }
  ]
}
```

数据结构：
```javascript
{
  message_id: 'M20251119...',
  contact_id: 'bob_uuid',
  encrypted_content: string,  // Base64
  decrypted_content: string,  // 解密后的明文
  decrypted_at: timestamp,
  created_at: timestamp
}
```

##### e) master_key_salt（主密钥盐值）

```javascript
{
  storeName: 'master_key_salt',
  keyPath: 'id',
  value: 1  // 只有一条记录
}
```

数据结构：
```javascript
{
  id: 1,
  salt: Uint8Array,  // PBKDF2 的 salt
  iterations: 100000,
  created_at: timestamp
}
```

---

## 5. 实现流程

### 5.1 注册流程

#### 客户端流程

1. **用户输入**
   - 账号（account）
   - 昵称（nickname）
   - 密码（password）

2. **密钥生成**
   ```
   a) 生成随机 Salt (32 字节)
   b) PBKDF2(密码, Salt, 100000 次迭代) → Master Key (32 字节)
   c) 生成身份密钥对 (Ed25519)
   d) 生成签名预密钥对 (Curve25519)
   e) 用身份私钥签名签名预公钥
   f) 生成 100 个一次性预密钥对 (Curve25519)
   ```

3. **加密存储私钥**
   ```
   a) 使用 Master Key 加密所有私钥
   b) 存储到 IndexedDB (user_keys)
   c) 存储 Salt 到 IndexedDB
   ```

4. **上传公钥到服务器**
   ```json
   POST /register
   {
     "account": "apple999",
     "nickname": "灰苹果",
     "password_hash": "SHA256(password)",  // 用于登录验证
     "identity_key_public": "Base64(...)",
     "signed_pre_key": {
       "key_id": 1,
       "public_key": "Base64(...)",
       "signature": "Base64(...)"
     },
     "one_time_pre_keys": [
       {"key_id": 1, "public_key": "Base64(...)"},
       {"key_id": 2, "public_key": "Base64(...)"},
       ...
       {"key_id": 100, "public_key": "Base64(...)"}
     ]
   }
   ```

#### 服务器流程

1. **验证注册信息**
   - 检查 account 是否已存在
   - 验证公钥格式

2. **存储用户数据**
   ```
   a) 插入 user_info 表（包括身份公钥、签名预公钥）
   b) 批量插入 one_time_pre_keys 表
   c) 返回 JWT token
   ```

3. **响应**
   ```json
   {
     "code": 200,
     "message": "注册成功",
     "data": {
       "token": "JWT...",
       "uuid": "U2025111918835697858",
       "account": "apple999",
       "nickname": "灰苹果"
     }
   }
   ```

### 5.2 登录流程

#### 客户端流程

1. **用户输入**
   - 账号（account）
   - 密码（password）

2. **重新派生主密钥**
   ```
   a) 从 IndexedDB 读取 Salt
   b) PBKDF2(密码, Salt, 100000 次迭代) → Master Key
   c) 验证主密钥（尝试解密一个已知密钥）
   d) 如果解密失败，密码错误
   ```

3. **登录请求**
   ```json
   POST /login
   {
     "account": "apple999",
     "password": "原始密码"  // 服务器会 bcrypt 验证
   }
   ```

4. **登录成功后**
   ```
   a) 解密所有私钥到内存
   b) 加载会话状态 (sessions)
   c) 检查一次性预密钥数量
   d) 如果少于 20 个，补充到 100 个
   ```

#### 服务器流程

1. **验证账号密码**（现有逻辑）
2. **返回用户信息 + Token**
3. **建立 WebSocket 连接**

### 5.3 首次会话流程（Alice → Bob）

#### Alice 客户端：发送首次消息

1. **获取 Bob 的公钥束**
   ```
   GET /user/getPublicKeyBundle?user_id=bob_uuid
   ```

2. **服务器返回**
   ```json
   {
     "code": 200,
     "data": {
       "user_id": "bob_uuid",
       "identity_key": "Base64(IK_B)",
       "signed_pre_key": {
         "key_id": 1,
         "public_key": "Base64(SPK_B)",
         "signature": "Base64(Sig)"
       },
       "one_time_pre_key": {
         "key_id": 42,
         "public_key": "Base64(OPK_B)"
       }
     }
   }
   ```

3. **Alice 验证签名**
   ```
   Ed25519.verify(IK_B, SPK_B, Signature)
   ```

4. **执行 X3DH 协商**
   ```
   a) 生成临时密钥 EK_A
   b) 执行 4 次 ECDH
   c) 派生会话密钥 (Root Key, Chain Keys)
   d) 存储会话状态到 IndexedDB
   ```

5. **加密消息**
   ```
   a) 从 sending_chain_key 派生 message_key
   b) AES-256-GCM 加密消息内容
   c) 构造 PreKeyMessage
   ```

6. **发送消息**
   ```json
   POST /message/sendEncryptedMessage
   {
     "session_id": "S20251119...",
     "receiver_id": "bob_uuid",
     "is_encrypted": true,
     "message_type": "PreKeyMessage",
     "content": "Base64(整个 PreKeyMessage JSON)"
   }
   ```

#### 服务器：转发消息

1. **存储加密消息**到 message 表
2. **通过 WebSocket 转发**给 Bob
3. **标记一次性预密钥**为已使用

#### Bob 客户端：接收首次消息

1. **收到 WebSocket 消息**

2. **解析 PreKeyMessage**
   ```
   a) 提取 identity_key (IK_A)
   b) 提取 ephemeral_key (EK_A)
   c) 提取 used_one_time_pre_key_id
   ```

3. **查找对应私钥**
   ```
   a) 从 IndexedDB 读取 IK_B_private
   b) 从 IndexedDB 读取 SPK_B_private
   c) 从 IndexedDB 读取 OPK_B_private (key_id=42)
   ```

4. **执行 X3DH 协商**
   ```
   a) 执行 4 次 ECDH (相同计算)
   b) 派生相同的会话密钥
   c) 存储会话状态到 IndexedDB
   d) 删除已使用的 OPK_B 私钥
   ```

5. **解密消息**
   ```
   a) 从 receiving_chain_key 派生 message_key
   b) AES-GCM 解密消息
   c) 显示明文给用户
   ```

6. **更新链密钥**

### 5.4 后续消息流程

#### 发送消息

1. **检查会话是否存在**
   - 从 IndexedDB 读取 session

2. **执行 DH 棘轮（如果需要）**
   ```
   if (send_counter % 100 == 0) {
     生成新的 DH 密钥对
     更新 Root Key 和 Chain Keys
   }
   ```

3. **派生消息密钥**
   ```
   message_key = KDF(sending_chain_key, "MessageKey")
   ```

4. **加密消息**
   ```
   ciphertext, iv, auth_tag = AES-GCM(message_key, plaintext)
   ```

5. **更新链密钥和计数器**
   ```
   sending_chain_key = KDF(sending_chain_key, "ChainKey")
   send_counter += 1
   ```

6. **构造 SignalMessage**
   ```json
   {
     "type": "SignalMessage",
     "sender_id": "alice_uuid",
     "receiver_id": "bob_uuid",
     "ratchet_key": "Base64(current_dh_public)",
     "counter": 15,
     "prev_counter": 12,
     "ciphertext": "Base64(...)",
     "iv": "Base64(...)",
     "auth_tag": "Base64(...)"
   }
   ```

7. **发送到服务器**

8. **保存会话状态**到 IndexedDB

#### 接收消息

1. **收到 SignalMessage**

2. **检查会话状态**
   - 从 IndexedDB 读取 session

3. **检查是否需要 DH 棘轮更新**
   ```
   if (message.ratchet_key != current_receiving_ratchet_key) {
     执行 DH 棘轮更新
     更新 Root Key 和 Chain Keys
   }
   ```

4. **处理消息序号**
   ```
   if (message.counter == receive_counter) {
     // 正常顺序消息
     派生消息密钥
     解密
     更新链密钥和计数器
   } else if (message.counter > receive_counter) {
     // 乱序消息
     派生并缓存跳过的消息密钥
     派生当前消息密钥
     解密
     更新链密钥和计数器
   } else {
     // 延迟消息
     从 message_keys_cache 查找密钥
     解密
   }
   ```

5. **解密消息**

6. **更新会话状态**

7. **显示明文**

### 5.5 密钥轮换流程

#### 签名预密钥轮换（每 30 天）

1. **客户端生成新的签名预密钥对**
2. **用身份私钥签名新公钥**
3. **上传到服务器**
   ```json
   POST /user/rotateSigned PreKey
   {
     "signed_pre_key": {
       "key_id": 2,
       "public_key": "Base64(...)",
       "signature": "Base64(...)"
     }
   }
   ```

4. **服务器更新 user_info 表**

#### 一次性预密钥补充（少于 20 个时）

1. **客户端检测**
   ```
   GET /user/getOneTimePreKeyCount
   → { "count": 15 }
   ```

2. **生成新的预密钥**
   ```
   生成 85 个新的 One-Time Pre Keys (补足到 100)
   ```

3. **上传到服务器**
   ```json
   POST /user/replenishOneTimePreKeys
   {
     "keys": [
       {"key_id": 101, "public_key": "Base64(...)"},
       ...
     ]
   }
   ```

---

## 6. API 设计

### 6.1 新增接口

#### 获取用户公钥束
```
GET /user/getPublicKeyBundle
Query: user_id=bob_uuid
Response: {
  "code": 200,
  "data": {
    "user_id": "bob_uuid",
    "identity_key": "Base64(...)",
    "signed_pre_key": {...},
    "one_time_pre_key": {...} or null
  }
}
```

#### 发送加密消息
```
POST /message/sendEncryptedMessage
Body: {
  "session_id": "S20251119...",
  "receiver_id": "bob_uuid",
  "is_encrypted": true,
  "message_type": "PreKeyMessage" | "SignalMessage",
  "content": "Base64(加密消息 JSON)"
}
Response: { "code": 200, "message": "发送成功" }
```

#### 轮换签名预密钥
```
POST /user/rotateSignedPreKey
Body: {
  "signed_pre_key": {
    "key_id": 2,
    "public_key": "Base64(...)",
    "signature": "Base64(...)"
  }
}
```

#### 补充一次性预密钥
```
POST /user/replenishOneTimePreKeys
Body: {
  "keys": [...]
}
```

#### 查询剩余一次性预密钥数量
```
GET /user/getOneTimePreKeyCount
Response: { "code": 200, "count": 15 }
```

### 6.2 修改现有接口

#### 注册接口修改
```
POST /register
增加字段：
  - identity_key_public
  - signed_pre_key
  - one_time_pre_keys (数组)
```

#### 获取消息列表修改
```
POST /message/getMessageList
Response 增加字段：
  - is_encrypted
  - message_type
  - encryption_version
  - 所有 Signal Protocol 字段
```

---

## 7. 前后端职责划分

### 7.1 前端职责

✅ **密钥管理**
- 生成所有密钥对
- 加密存储私钥
- 派生主密钥
- 密钥轮换

✅ **加密/解密**
- 执行 X3DH 协商
- 双棘轮算法实现
- AES-GCM 加密/解密
- 签名和验证

✅ **会话管理**
- 维护会话状态
- 更新链密钥
- 处理乱序消息

✅ **本地存储**
- IndexedDB 存储加密数据
- 消息密钥缓存

### 7.2 后端职责

✅ **密钥分发**
- 存储公钥
- 响应公钥束请求
- 管理一次性预密钥

✅ **消息转发**
- 存储加密消息（不解密）
- WebSocket 转发
- 消息持久化

✅ **密钥管理**
- 标记已使用的一次性预密钥
- 记录密钥轮换日志
- 检测密钥数量告警

✅ **身份验证**
- JWT 认证
- 账号密码验证

❌ **后端不做的事**
- 解密任何消息内容
- 存储任何私钥
- 存储明文消息

---

## 8. 安全性考虑

### 8.1 密钥存储安全

**客户端**：
- 主密钥从密码派生，不存储
- 私钥用主密钥加密后存储
- IndexedDB 数据加密
- 内存中的密钥及时清除

**服务器**：
- 只存储公钥
- 密码使用 bcrypt 哈希
- 使用 HTTPS/TLS 传输

### 8.2 前向安全

✅ **密钥单向派生**
- 新密钥无法推导旧密钥

✅ **消息密钥立即删除**
- 解密后立即删除消息密钥

✅ **DH 棘轮定期更新**
- 即使某个密钥泄露，影响有限

### 8.3 认证和完整性

✅ **签名验证**
- 签名预密钥由身份密钥签名
- 防止公钥替换攻击

✅ **AES-GCM 认证加密**
- 同时提供加密和完整性
- 防止消息篡改

### 8.4 防重放攻击

✅ **消息计数器**
- 每条消息有唯一计数器
- 客户端拒绝旧计数器的消息

✅ **一次性预密钥**
- 每个密钥只用一次
- 用完立即删除

### 8.5 已知风险

⚠️ **客户端安全**
- XSS 攻击可窃取内存中的密钥
- 恶意扩展可读取 IndexedDB
- **缓解**：CSP 策略、代码审计

⚠️ **元数据泄露**
- 服务器知道谁和谁聊天
- 知道消息发送时间
- **缓解**：本阶段无法解决

⚠️ **密码安全**
- 弱密码易被破解
- **缓解**：密码强度要求、2FA（后续）

---

## 9. 性能优化

### 9.1 密钥缓存

- 会话密钥常驻内存（登录期间）
- 避免频繁 IndexedDB 读取
- 定期清理过期的消息密钥缓存

### 9.2 异步加密

- 使用 Web Worker 进行加密/解密
- 不阻塞 UI 线程
- 批量处理历史消息解密

### 9.3 消息批量处理

- 接收多条消息时批量解密
- 减少 DOM 更新次数

### 9.4 预加载密钥

- 登录时预加载常用联系人的会话
- 打开会话时预解密最近消息

---

## 10. 实施步骤

### 阶段 1：基础设施（1 周）

**任务**：
- [ ] 数据库表设计和迁移脚本
- [ ] 前端 IndexedDB 封装
- [ ] 密钥生成和存储模块
- [ ] 主密钥派生和验证

**交付物**：
- 数据库迁移脚本
- 密钥管理 JS 模块

### 阶段 2：密钥协商（1 周）

**任务**：
- [ ] X3DH 协议实现
- [ ] 公钥束上传和获取 API
- [ ] 一次性预密钥管理
- [ ] 签名验证逻辑

**交付物**：
- X3DH 模块
- 后端公钥管理接口

### 阶段 3：消息加密（1 周）

**任务**：
- [ ] 双棘轮算法实现
- [ ] AES-GCM 加密/解密
- [ ] 发送加密消息
- [ ] 接收并解密消息

**交付物**：
- Signal Protocol 完整实现
- 加密消息收发流程

### 阶段 4：会话管理（1 周）

**任务**：
- [ ] 会话状态持久化
- [ ] DH 棘轮更新
- [ ] 乱序消息处理
- [ ] 消息密钥缓存

**交付物**：
- 会话管理模块
- 乱序消息处理逻辑

### 阶段 5：集成和优化（1 周）

**任务**：
- [ ] 修改注册/登录流程
- [ ] 修改消息发送界面
- [ ] 向后兼容处理（旧消息）
- [ ] 性能优化
- [ ] 错误处理和重试机制

**交付物**：
- 完整集成的加密聊天功能
- 兼容旧版本消息

### 阶段 6：测试和文档（1 周）

**任务**：
- [ ] 单元测试
- [ ] 集成测试
- [ ] 安全测试
- [ ] 性能测试
- [ ] 用户文档

**交付物**：
- 测试报告
- 用户使用文档

**总计：6 周开发周期**

---

## 11. 测试计划

### 11.1 单元测试

**密钥生成**：
- 生成的密钥对格式正确
- 签名验证通过
- ECDH 结果一致

**加密/解密**：
- 加密后无法识别原文
- 解密后还原原文
- 篡改密文后解密失败

**X3DH 协商**：
- Alice 和 Bob 派生相同会话密钥
- 签名验证失败时拒绝会话

**双棘轮**：
- 链密钥正确更新
- DH 棘轮正确更新
- 消息密钥不重复

### 11.2 集成测试

**完整会话**：
1. Alice 注册并生成密钥
2. Bob 注册并生成密钥
3. Alice 给 Bob 发首条消息
4. Bob 收到并解密
5. Bob 回复
6. Alice 收到并解密
7. 连续发送 200 条消息（跨越 DH 棘轮）

**乱序消息**：
1. Alice 发送 10 条消息
2. Bob 以乱序接收（如 3, 1, 5, 2, 4...）
3. 所有消息正确解密

**密钥轮换**：
1. 模拟 30 天后
2. 轮换签名预密钥
3. 后续消息正常收发

### 11.3 安全测试

**中间人攻击**：
- 替换公钥后签名验证失败
- 会话建立失败

**重放攻击**：
- 重复发送旧消息
- 客户端拒绝（计数器检查）

**密钥泄露**：
- 假设某个消息密钥泄露
- 其他消息无法解密

### 11.4 性能测试

**加密性能**：
- 单条消息加密时间 < 10ms
- 批量 100 条消息加密时间 < 500ms

**解密性能**：
- 单条消息解密时间 < 10ms
- 历史消息加载（100 条）< 1s

**密钥操作**：
- X3DH 协商时间 < 100ms
- DH 棘轮更新时间 < 50ms

---

## 12. 向后兼容

### 12.1 兼容策略

**旧用户（无加密密钥）**：
- 登录时提示"启用端到端加密"
- 生成密钥并上传
- 后续消息使用加密

**旧消息（未加密）**：
- `is_encrypted = FALSE`
- 直接显示明文
- 标记为"未加密消息"

**新旧用户互发**：
- 如果对方无加密密钥，fallback 到明文
- 提示"对方未启用加密"

### 12.2 数据迁移

**Phase 1：软发布**
- 新用户默认启用加密
- 旧用户可选启用
- 旧消息保持明文

**Phase 2：全面推广**
- 所有用户强制启用
- 提供密钥导出/导入工具

**Phase 3：完全加密**
- 不再支持明文消息
- 删除 `is_encrypted` 字段

---

## 13. 用户体验

### 13.1 透明加密

**目标**：用户无感知加密过程

- 加密在后台自动进行
- 无需用户手动操作
- 发送/接收体验不变

### 13.2 加密指示

**加密状态显示**：
- 🔒 消息旁显示"已加密"标识
- 🔓 旧消息显示"未加密"标识
- 会话界面显示"端到端加密"

### 13.3 密钥管理

**用户可见操作**：
- 查看自己的身份密钥指纹
- 验证对方身份密钥（可选）
- 查看会话加密状态

### 13.4 错误处理

**友好提示**：
- "正在建立安全连接..."
- "消息解密中..."
- "加密密钥不匹配，请联系对方"

---

## 14. 监控和告警

### 14.1 服务器监控

- 一次性预密钥库存告警（< 20 个）
- 密钥轮换超时告警（> 35 天）
- 加密消息发送失败率

### 14.2 客户端监控

- 解密失败次数
- X3DH 协商失败次数
- IndexedDB 存储容量

---

## 15. 依赖库

### 15.1 前端（Vue.js）

**加密库**：
```javascript
// TweetNaCl: 轻量级加密库
import nacl from 'tweetnacl'
import naclUtil from 'tweetnacl-util'

// Signal Protocol 实现（可选）
import { SignalProtocolStore } from '@privacyresearch/libsignal-protocol-typescript'

// 或者自行实现（推荐学习）
```

**工具库**：
```javascript
// Base64 编解码
import { encode, decode } from 'base64-arraybuffer'

// PBKDF2 密钥派生
import { pbkdf2 } from 'crypto-browserify'
```

### 15.2 后端（Go）

**加密库**：
```go
import (
    "crypto/ed25519"
    "crypto/rand"
    
    "golang.org/x/crypto/curve25519"
    "golang.org/x/crypto/hkdf"
)
```

**工具库**：
```go
import (
    "encoding/base64"
    "encoding/json"
)
```

---

## 16. 总结

### 16.1 实现要点

✅ **简化设计**
- 专注单聊，暂不考虑群组
- 使用成熟的 Signal Protocol
- 优先保证安全性

✅ **向后兼容**
- 支持新旧消息共存
- 平滑升级路径

✅ **用户体验**
- 透明加密，无感知
- 错误提示友好

### 16.2 关键挑战

⚠️ **密钥管理复杂度**
- 多种密钥类型
- 密钥轮换机制
- 本地安全存储

⚠️ **会话状态同步**
- 双棘轮状态维护
- 乱序消息处理
- 断线重连恢复

⚠️ **性能优化**
- 加密/解密性能
- 历史消息批量处理
- IndexedDB 读写性能

### 16.3 后续扩展

🔮 **第二阶段：群组加密**
- Sender Keys 实现
- 群组密钥分发

🔮 **第三阶段：跨设备同步**
- 多设备密钥同步
- 设备管理

🔮 **第四阶段：高级功能**
- 密钥安全码验证
- 消息自毁
- 屏幕截图保护

---

**文档版本**: 1.0  
**创建日期**: 2025-11-19  
**目标版本**: v2.0  
**预计开发周期**: 6 周  

**下一步行动**：开始阶段 1 的数据库设计和密钥管理模块开发。

