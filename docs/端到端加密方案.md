# 端到端加密聊天系统设计方案

## 1. 系统目标

### 核心需求
- ✅ **端到端加密**：服务器无法解密聊天内容
- ✅ **跨设备访问**：在多个设备上访问历史消息
- ✅ **群组历史消息**：新成员加群后可查看历史消息
- ✅ **身份验证**：确保消息来自真实发送者
- ✅ **前向安全**：密钥泄露不影响历史消息安全

### 安全原则
- 服务器只存储加密后的消息
- 密钥仅在客户端生成和管理
- 每条消息使用不同的加密密钥

---

## 2. 密钥体系架构

### 2.1 用户密钥对（长期密钥）

每个用户注册时生成 3 对密钥：

#### a) 身份密钥对 (Identity Key Pair)
- **用途**：用户身份标识，签名其他公钥
- **算法**：Ed25519（签名）
- **存储**：
  - 私钥：本地加密存储（使用用户主密钥加密）
  - 公钥：上传服务器公开

#### b) 签名前密钥对 (Signed Pre Key)
- **用途**：建立会话时使用
- **算法**：Curve25519（密钥交换）
- **生命周期**：定期轮换（每 7-30 天）
- **存储**：
  - 私钥：本地加密存储
  - 公钥：上传服务器，由身份密钥签名

#### c) 一次性预密钥 (One-Time Pre Keys)
- **用途**：提供前向安全性
- **算法**：Curve25519
- **数量**：预生成 100 个
- **使用**：用一次删一次，用完补充
- **存储**：
  - 私钥：本地加密存储
  - 公钥：上传服务器

### 2.2 用户主密钥 (Master Key)

```
主密钥派生流程：
用户密码 + Salt → PBKDF2 (100,000 迭代) → 主密钥 (256 bit)
                                          ↓
                     ┌──────────────────┬─────────────┬──────────────┐
                     ↓                  ↓             ↓              ↓
              本地存储加密密钥     数据库加密密钥   验证密钥   备份加密密钥
```

**作用**：
- 加密所有本地存储的私钥
- 加密本地数据库
- 服务器验证（使用派生的验证密钥）

**存储**：
- **不存储**原始主密钥
- 使用 PBKDF2 派生多个子密钥
- 验证密钥的 Hash 存储在服务器

---

## 3. 单聊加密方案

### 3.1 Signal Protocol（双棘轮算法）

采用改进的 Signal Protocol，提供：
- 端到端加密
- 前向安全
- 后向安全（破坏后的安全性）

#### 会话建立流程（X3DH 协议）

```
Alice 想给 Bob 发第一条消息：

1. Alice 从服务器获取 Bob 的公钥束：
   - Identity Key (IK_B)
   - Signed Pre Key (SPK_B)
   - One-Time Pre Key (OPK_B) [可选]

2. Alice 生成临时密钥对：
   - Ephemeral Key (EK_A)

3. Alice 执行 4 次 ECDH 密钥交换：
   DH1 = ECDH(IK_A, SPK_B)
   DH2 = ECDH(EK_A, IK_B)
   DH3 = ECDH(EK_A, SPK_B)
   DH4 = ECDH(EK_A, OPK_B)  [如果有 OPK]

4. 派生初始会话密钥：
   SK = KDF(DH1 || DH2 || DH3 || DH4)

5. Alice 发送初始消息：
   - IK_A（身份密钥）
   - EK_A（临时密钥）
   - OPK_B 的 ID
   - 加密消息
```

#### 双棘轮机制

```
发送消息时：
┌─────────────────┐
│  对称密钥棘轮    │ → 每条消息生成新的消息密钥
│  (KDF Chain)    │
└────────┬────────┘
         │
    ┌────▼────┐
    │ Root Key │ ← 发送方链密钥 + 接收方链密钥
    └────┬────┘
         │
┌────────▼────────┐
│  DH 棘轮         │ → 每次发送/接收消息后更新 DH 密钥对
│  (DH Ratchet)   │
└─────────────────┘
```

**关键特性**：
- 每条消息用不同密钥加密
- 即使某个密钥泄露，不影响其他消息
- 自动修复（如果中间人攻击被发现）

### 3.2 消息加密格式

```json
{
  "version": 1,
  "sender_id": "UUID",
  "receiver_id": "UUID",
  "ratchet_key": "当前 DH 公钥（Base64）",
  "counter": 12,  // 消息序号
  "prev_counter": 10,  // 上一个链的序号
  "ciphertext": "AES-256-GCM 加密的消息（Base64）",
  "iv": "初始化向量（Base64）",
  "auth_tag": "认证标签（Base64）"
}
```

**加密过程**：
```
1. 从当前链密钥派生消息密钥：
   Message_Key = KDF(Chain_Key, "message_key")
   
2. 使用 AES-256-GCM 加密：
   Ciphertext = AES-GCM-Encrypt(Message_Key, Plaintext)
   
3. 更新链密钥：
   Chain_Key = KDF(Chain_Key, "chain_key")
```

---

## 4. 群组加密方案

### 4.1 Sender Keys（发送者密钥）

为每个群组成员分配一个发送者密钥，用于加密自己发送的消息。

```
群组结构：
┌──────────────────────────────────┐
│         群组 (Group)              │
├──────────────────────────────────┤
│  成员 A → Sender Key A           │
│  成员 B → Sender Key B           │
│  成员 C → Sender Key C           │
│  成员 D → Sender Key D           │
└──────────────────────────────────┘
```

#### 发送者密钥结构

```javascript
SenderKey {
  sender_chain_key: "链密钥",  // 用于派生消息密钥
  sender_signature_key: "签名密钥",  // 用于消息签名
  iteration: 0  // 密钥代数
}
```

#### 群消息发送流程

```
1. Alice 在群里发消息：
   
   a) 使用自己的 Sender Chain Key 派生消息密钥
   b) 用消息密钥加密消息内容
   c) 用签名密钥签名消息
   d) 发送到服务器
   
2. 群成员 Bob、Carol、Dave 收到消息：
   
   a) 使用 Alice 的 Sender Chain Key 派生相同的消息密钥
   b) 解密消息
   c) 验证签名
```

### 4.2 群组密钥分发

#### 新成员加入

```
方案 A：管理员重新分发（推荐）

1. 管理员 Admin 邀请新成员 Eve：
   
   a) Admin 生成新的群组密钥包：
      - 为每个现有成员生成新的 Sender Key
      - 为 Eve 生成 Sender Key
      
   b) Admin 使用端到端加密（Signal Protocol）
      分别发送密钥包给每个成员：
      
      To Bob:   E(Bob_Key, [Sender_A_New, Sender_C_New, Sender_D_New, Sender_Eve])
      To Carol: E(Carol_Key, [Sender_A_New, Sender_B_New, Sender_D_New, Sender_Eve])
      To Eve:   E(Eve_Key, [Sender_A_New, Sender_B_New, Sender_C_New, Sender_D_New])
      
   c) 所有成员收到后，更新本地的 Sender Keys
   
   d) Eve 可以解密后续所有消息
```

```
方案 B：历史消息密钥分享（可选）

如果要让 Eve 看到历史消息：

1. Admin 决定分享多少历史消息（如最近 1000 条）

2. 对于每条历史消息：
   - 从原 Sender 的密钥链重新派生当时的消息密钥
   - 用 Eve 的公钥加密这些消息密钥
   
3. 形成历史消息密钥包：
   {
     "msg_id_1": E(Eve_Key, Original_Message_Key_1),
     "msg_id_2": E(Eve_Key, Original_Message_Key_2),
     ...
   }
   
4. Eve 收到后：
   - 解密消息密钥
   - 用消息密钥解密历史消息
```

#### 成员退出

```
1. 成员 Bob 退出群组：
   
   a) 管理员通知所有在线成员
   
   b) 所有成员删除 Bob 的 Sender Key
   
   c) 生成新的群组代次（Generation）
   
   d) 为所有剩余成员重新生成 Sender Keys
   
   e) 后续消息 Bob 无法解密（前向安全）
```

### 4.3 群组密钥轮换

定期轮换密钥以提高安全性：

```
轮换策略：
1. 时间触发：每 30 天轮换一次
2. 事件触发：成员变动时轮换
3. 手动触发：管理员可主动轮换

轮换过程：
1. 生成新的 Sender Keys for 所有成员
2. 加密分发给所有成员
3. 标记旧密钥为"仅解密"（可解密历史消息）
4. 新消息使用新密钥加密
```

---

## 5. 跨设备同步方案

### 5.1 设备密钥管理

```
用户架构：
User (Alice)
  ├─ Device 1 (手机)
  │   ├─ Device Identity Key
  │   ├─ Device Signed Pre Key
  │   └─ Device One-Time Pre Keys
  │
  ├─ Device 2 (电脑)
  │   ├─ Device Identity Key
  │   ├─ Device Signed Pre Key
  │   └─ Device One-Time Pre Keys
  │
  └─ Device 3 (平板)
      ├─ Device Identity Key
      ├─ Device Signed Pre Key
      └─ Device One-Time Pre Keys
```

#### 新设备添加流程

```
Alice 在新设备（电脑）上登录：

1. 电脑生成新的设备密钥对

2. 主设备（手机）扫码确认：
   - 验证新设备的身份
   - 建立设备间的 Signal 会话
   
3. 手机向电脑发送：
   a) 用户主密钥（加密后）
   b) 所有会话的密钥（加密后）
   c) 所有群组的 Sender Keys（加密后）
   
4. 电脑解密后：
   - 存储到本地安全存储
   - 可以解密历史消息
   - 可以发送新消息
```

### 5.2 会话密钥同步

```
同步策略：

方案 A：实时同步（推荐）
- 新设备通过端到端加密从主设备接收密钥
- 使用设备间 Signal Protocol

方案 B：服务器中转（加密存储）
- 密钥用设备公钥加密后存储在服务器
- 新设备用私钥解密获取
```

#### 密钥同步数据结构

```json
{
  "sync_version": 1,
  "sync_time": "2025-11-18T20:00:00Z",
  "target_device_id": "device_2_uuid",
  "encrypted_keys": {
    "master_key": "E(Device2_PubKey, MasterKey)",
    "contacts": [
      {
        "contact_id": "bob_uuid",
        "session_state": "E(Device2_PubKey, SessionState)",
        "message_keys": "E(Device2_PubKey, MessageKeys)"
      }
    ],
    "groups": [
      {
        "group_id": "group_1_uuid",
        "sender_keys": "E(Device2_PubKey, SenderKeys)",
        "generation": 5
      }
    ]
  }
}
```

---

## 6. 数据库设计

### 6.1 服务器数据库（只存加密数据）

#### 用户表增加字段
```sql
ALTER TABLE user_info ADD COLUMN identity_key_public TEXT;  -- 身份公钥
ALTER TABLE user_info ADD COLUMN signed_pre_key_public TEXT;  -- 签名预公钥
ALTER TABLE user_info ADD COLUMN signed_pre_key_signature TEXT;  -- 公钥签名
ALTER TABLE user_info ADD COLUMN key_generation INT DEFAULT 0;  -- 密钥代数
```

#### 一次性预密钥表
```sql
CREATE TABLE one_time_pre_keys (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(20) NOT NULL,
    key_id INT NOT NULL,
    public_key TEXT NOT NULL,
    uploaded_at TIMESTAMP NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    used_at TIMESTAMP,
    UNIQUE(user_id, key_id)
);
```

#### 设备表
```sql
CREATE TABLE user_devices (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(20) NOT NULL,
    device_id VARCHAR(50) NOT NULL,
    device_name VARCHAR(100),
    device_identity_key TEXT NOT NULL,
    device_signed_pre_key TEXT NOT NULL,
    last_active_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL,
    UNIQUE(user_id, device_id)
);
```

#### 群组密钥分发记录表
```sql
CREATE TABLE group_key_distributions (
    id BIGSERIAL PRIMARY KEY,
    group_id VARCHAR(20) NOT NULL,
    generation INT NOT NULL,
    distributed_by VARCHAR(20) NOT NULL,  -- 分发者
    distributed_at TIMESTAMP NOT NULL,
    member_count INT NOT NULL
);
```

#### 加密消息表（改造现有 message 表）
```sql
ALTER TABLE message ADD COLUMN encryption_version INT DEFAULT 1;
ALTER TABLE message ADD COLUMN ratchet_key TEXT;  -- DH 公钥
ALTER TABLE message ADD COLUMN counter INT;  -- 消息计数器
ALTER TABLE message ADD COLUMN prev_counter INT;  -- 前一个链的计数
ALTER TABLE message ADD COLUMN iv TEXT;  -- 初始化向量
ALTER TABLE message ADD COLUMN auth_tag TEXT;  -- 认证标签

-- content 和 url 字段现在存储加密后的数据
-- 服务器无法解密
```

### 6.2 客户端本地数据库

```sql
-- 会话状态表
CREATE TABLE sessions (
    contact_id VARCHAR(20) PRIMARY KEY,
    root_key BLOB NOT NULL,
    chain_key_send BLOB NOT NULL,
    chain_key_receive BLOB NOT NULL,
    sending_ratchet_key BLOB NOT NULL,
    receiving_ratchet_key BLOB,
    prev_counter INT DEFAULT 0,
    counter INT DEFAULT 0,
    updated_at TIMESTAMP NOT NULL
);

-- 消息密钥缓存（用于乱序消息）
CREATE TABLE message_keys_cache (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id VARCHAR(20) NOT NULL,
    ratchet_key BLOB NOT NULL,
    counter INT NOT NULL,
    message_key BLOB NOT NULL,
    created_at TIMESTAMP NOT NULL,
    UNIQUE(contact_id, ratchet_key, counter)
);

-- 群组发送者密钥
CREATE TABLE group_sender_keys (
    group_id VARCHAR(20) NOT NULL,
    sender_id VARCHAR(20) NOT NULL,
    chain_key BLOB NOT NULL,
    signature_key BLOB NOT NULL,
    generation INT NOT NULL,
    iteration INT DEFAULT 0,
    PRIMARY KEY(group_id, sender_id, generation)
);

-- 用户私钥（加密存储）
CREATE TABLE user_keys (
    key_type VARCHAR(50) PRIMARY KEY,  -- 'identity', 'signed_pre', 'one_time_pre_1'
    private_key BLOB NOT NULL,  -- 用主密钥加密
    public_key TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL
);
```

---

## 7. 实现流程

### 7.1 注册流程

```
1. 用户输入用户名、密码
2. 客户端：
   a) 生成 Salt
   b) PBKDF2(密码, Salt) → 主密钥
   c) 生成 3 对密钥（Identity, Signed Pre, One-Time Pre）
   d) 用主密钥加密私钥
   e) 发送公钥到服务器
3. 服务器：
   a) 存储公钥
   b) 返回注册成功
```

### 7.2 首次会话流程

```
Alice 给 Bob 发第一条消息：

1. Alice 客户端：
   a) 从服务器获取 Bob 的公钥束
   b) 执行 X3DH 协议建立会话
   c) 用会话密钥加密消息
   d) 发送加密消息到服务器

2. 服务器：
   a) 存储加密消息（无法解密）
   b) 转发给 Bob

3. Bob 客户端：
   a) 收到消息
   b) 执行 X3DH 协议建立相同会话
   c) 解密消息
   d) 显示明文
```

### 7.3 群组首次发送流程

```
Alice 在群里发第一条消息：

1. 检查本地是否有群组的 Sender Keys
   - 如果没有，向服务器请求
   
2. 服务器返回：
   - 群主分发的加密 Sender Keys
   - Alice 用自己的私钥解密
   
3. Alice 加密消息：
   a) 从自己的 Sender Chain Key 派生消息密钥
   b) AES-256-GCM 加密消息
   c) 用签名密钥签名
   d) 发送到服务器
   
4. 服务器存储并转发给群成员
```

---

## 8. 安全性分析

### 8.1 威胁模型

#### 已防护的攻击

✅ **服务器攻击**
- 服务器被入侵，攻击者只能看到加密数据
- 无法解密任何消息内容

✅ **中间人攻击（MITM）**
- Signal Protocol 的 X3DH 提供认证
- 身份密钥签名防止公钥替换

✅ **密钥泄露（前向安全）**
- 即使某个密钥泄露，历史消息仍安全
- 双棘轮机制提供自动修复

✅ **设备被盗**
- 主密钥由密码派生，强密码保护
- 可远程撤销设备权限

✅ **量子计算攻击（部分）**
- 可升级到抗量子算法（如 CRYSTALS-Kyber）

#### 仍存在的风险

⚠️ **终端安全**
- 如果客户端被恶意软件感染，明文可被窃取
- 缓解：定期安全审计、代码签名

⚠️ **社会工程学**
- 用户可能被欺骗泄露密码
- 缓解：安全教育、2FA

⚠️ **元数据泄露**
- 服务器知道谁和谁聊天、聊天时间
- 缓解：混合网络、匿名路由（需要额外设计）

### 8.2 合规性考虑

⚠️ **法律风险**
- 某些国家可能要求后门
- 执法部门可能要求访问数据

**应对策略**：
1. 服务器真的无法解密（技术不可能）
2. 提供透明度报告
3. 考虑使用 warrant canary
4. 开源客户端代码供审计

---

## 9. 性能优化

### 9.1 消息缓存策略

```
本地缓存：
- 解密后的消息存储 7 天
- 超过 7 天的消息需要重新解密
- 减少重复解密操作
```

### 9.2 密钥预加载

```
启动时：
- 预加载最近联系人的会话密钥
- 预加载活跃群组的 Sender Keys
- 减少首次发送延迟
```

### 9.3 批量操作

```
群消息：
- 批量解密多条消息
- 利用 CPU 并行能力
```

---

## 10. 实施路线图

### 第一阶段：基础加密（2-3 周）
- [ ] 实现 Signal Protocol 核心库
- [ ] 单聊端到端加密
- [ ] 密钥生成和管理
- [ ] 数据库设计改造

### 第二阶段：群组加密（2-3 周）
- [ ] Sender Keys 实现
- [ ] 群组密钥分发机制
- [ ] 成员变动处理
- [ ] 历史消息访问

### 第三阶段：跨设备支持（2 周）
- [ ] 设备管理
- [ ] 密钥同步机制
- [ ] 多设备消息同步

### 第四阶段：优化和测试（2 周）
- [ ] 性能优化
- [ ] 安全审计
- [ ] 兼容性测试
- [ ] 文档完善

**总计：8-10 周开发周期**

---

## 11. 依赖库推荐

### Go 后端
```go
// 加密库
github.com/golang/crypto/curve25519
github.com/golang/crypto/ed25519
github.com/golang/crypto/nacl/box

// Signal Protocol 实现
github.com/RadicalApp/libsignal-protocol-go
```

### Vue 前端
```javascript
// 加密库
import { generateKeyPair, sign, verify } from 'tweetnacl'
import { box, randomBytes } from 'tweetnacl'

// Signal Protocol 实现
import { SignalProtocolStore } from '@signalapp/libsignal-client'
```

---

## 12. 总结

### 关键设计决策

1. **Signal Protocol**：业界验证的端到端加密协议
2. **Sender Keys**：高效的群组加密方案
3. **设备间同步**：支持无缝跨设备体验
4. **前向安全**：密钥泄露不影响历史消息

### 权衡取舍

**选择**：群成员可查看历史消息
**代价**：需要存储和分发历史消息密钥
**理由**：用户体验更重要

**选择**：支持多设备
**代价**：增加密钥管理复杂度
**理由**：现代用户的基本需求

### 后续改进方向

1. **零知识证明**：证明消息有效性而不泄露内容
2. **同态加密**：在加密数据上进行搜索
3. **抗量子算法**：应对未来量子计算威胁
4. **元数据保护**：混合网络隐藏通信模式

---

## 附录：参考资料

1. [Signal Protocol 规范](https://signal.org/docs/)
2. [Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/)
3. [X3DH Key Agreement Protocol](https://signal.org/docs/specifications/x3dh/)
4. [Sesame Algorithm for Group Messaging](https://eprint.iacr.org/2017/713.pdf)
5. [WhatsApp Security Whitepaper](https://www.whatsapp.com/security/)

---

**文档版本**: 1.0
**创建日期**: 2025-11-18
**作者**: AI Assistant
**状态**: 设计阶段

